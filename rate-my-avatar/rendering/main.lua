local function divide(a, b)
    if b == 0 or a == 0 then
        return 0
    else
        return a / b
    end
end

function rotate(wireframe, c, yaw, pitch) -- function generated by chatgpt, god bless chatgpt for saving this project
    local yaw = math.rad(yaw)
    local pitch = math.rad(pitch)
    
    local cos_yaw = math.cos(yaw)
    local sin_yaw = math.sin(yaw)
    local cos_pitch = math.cos(pitch)
    local sin_pitch = math.sin(pitch)
    
    local rotated_points = {}
    for _, point in pairs(wireframe) do
        if type(point) == "table" then
            local x = point[1] - c[1]
            local y = point[2] - c[2]
            local z = point[3] - c[3]
            
            local x_ = x * cos_yaw - z * sin_yaw
            local z_ = x * sin_yaw + z * cos_yaw
            
            local y_ = y * cos_pitch - z_ * sin_pitch
            local z__ = y * sin_pitch + z_ * cos_pitch
            
            x = x_ + c[1]
            y = y_ + c[2]
            z = z__ + c[3]
            
            table.insert(rotated_points, {x, y, z})
        end
    end
    return rotated_points
end

local function getcube(x, y, z, size, offset)
    local offset_x, offset_y, offset_z = unpack(offset)
    return {
        "cube",
        {x + offset_x, y + offset_y, z + offset_z},
        {x + offset_x, y + offset_y, z + size + offset_z},
        {x + offset_x, y + size + offset_y, z + offset_z},
        {x + offset_x, y + size + offset_y, z + size + offset_z},
        {x + size + offset_x, y + offset_y, z + offset_z},
        {x + size + offset_x, y + offset_y, z + size + offset_z},
        {x + size + offset_x, y + size + offset_y, z + offset_z},
        {x + size + offset_x, y + size + offset_y, z + size + offset_z},
    }
end

local function rotatewireframes(wireframes, rotation, center)
    local wireframetoreturn = {}
    for _, wireframe in pairs(wireframes) do
        local afterrotated = rotate(wireframe, center, rotation[1], rotation[2])
        if wireframe[1] == "cube" then
            local edges = {
                {afterrotated[1], afterrotated[2]},
                {afterrotated[1], afterrotated[3]},
                {afterrotated[2], afterrotated[4]},
                {afterrotated[3], afterrotated[4]},
                {afterrotated[5], afterrotated[6]},
                {afterrotated[5], afterrotated[7]},
                {afterrotated[6], afterrotated[8]},
                {afterrotated[7], afterrotated[8]},
                {afterrotated[1], afterrotated[5]},
                {afterrotated[2], afterrotated[6]},
                {afterrotated[3], afterrotated[7]},
                {afterrotated[4], afterrotated[8]},
            }
            table.insert(wireframetoreturn, edges)
        end
    end
    return wireframetoreturn
end

local function raycast(points, focal_length, camera)
    local toreturn = {}
    for _, point in pairs(points) do
        local z1 = math.max(1, point[1][3])
        local z2 = math.max(1, point[2][3])
        local xp1 = (focal_length * point[1][1] / z1) + camera[1]
        local yp1 = (focal_length * point[1][2] / z1) + camera[2]
        local xp2 = (focal_length * point[2][1] / z2) + camera[1]
        local yp2 = (focal_length * point[2][2] / z2) + camera[2]
        
        table.insert(toreturn, {{xp1, yp1}, {xp2, yp2}})
    end
    return toreturn
end

local function dda(x1, y1, x2, y2)
    local dx = x2 - x1
    local dy = y2 - y1
    local steps
    if math.abs(dx) > math.abs(dy) then
        steps = math.abs(dx)
    else
        steps = math.abs(dy)
    end
    local x_inc = dx / steps
    local y_inc = dy / steps
    local x = x1
    local y = y1
    local points = {}
    for i = 0, math.floor(steps) do
        if math.max(x1, x2) >= x and x >= math.min(x1, x2) and math.max(y1, y2) >= y and y >= math.min(y1, y2) then
            table.insert(points, {math.round(x), math.round(y)})
            x = x + x_inc
            y = y + y_inc
        end
    end
    return points
end

local function renderthewireframes(wireframes, focal_length, camera, rotation)
    local timages = {}
    for y=1, 33, 1 do
        local temp_list = {}
        for x=1, 60, 1 do
            table.insert(temp_list, 0)
        end
        table.insert(timages, temp_list)
    end
    
    for _, wireframe in pairs(wireframes) do
        local afterrendered = raycast(wireframe, focal_length, camera)
        for _, edge in pairs(afterrendered) do
            local x1, y1, x2, y2 = edge[1][1], edge[1][2], edge[2][1], edge[2][2]
            local line_points = dda(x1, y1, x2, y2)
            for _, point in pairs(line_points) do
                if 60 >= point[1] and point[1] > 0 and 33 >= point[2] and point[2] > 0 then
                    timages[point[2]][point[1]] = 1
                end
            end
        end
    end
    
    --print(dump(timages))
    
    local finalstring = "\n"
    for y=1, 33, 1 do
        local temp_str = ""
        for x=1, 60, 1 do
            if timages[y][x] == 1 then
                temp_str = temp_str .. "ðŸ“˜"
            else
                temp_str = temp_str .. "ðŸŒ‘"
            end
        end
        finalstring = finalstring .. temp_str .. "\n"
    end
    return finalstring
end

local updateremote = game:GetService("ReplicatedStorage").CustomiseBooth
function update(text)
    local args = {
        [1] = "Update",
        [2] = {
            ["DescriptionText"] = text,
            ["ImageId"] = 0
        }
    }
    updateremote:FireServer(unpack(args))
end

local size = 30
local focal_length = 70

local camera_position = {25, 25, 0}
local translate_position = {-10, -40, 0}
local camera_rotation = {0, 0}

local UIS = game:GetService("UserInputService")
local buttonsDown = {}

UIS.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    local initTick = tick()
    while UIS:IsKeyDown(input.KeyCode) do
        buttonsDown[input.KeyCode] = true
        task.wait()
    end
    buttonsDown[input.KeyCode] = nil
end)

local function kbp(key)
    return buttonsDown[key] == true
end

_G.Enabled = true
while _G.Enabled do
    --print(translate_position[1], translate_position[2], translate_position[3])
    local angle = math.rad(camera_rotation[1]) -- movement relative to camera generated by chatgpt
    local x, y = math.cos(angle), math.sin(angle)
    if kbp(Enum.KeyCode.T) then
        translate_position = {translate_position[1] - (y * 1), translate_position[2], translate_position[3] - (x * 1)}
    elseif kbp(Enum.KeyCode.G) then
        translate_position = {translate_position[1] + (y * 1), translate_position[2], translate_position[3] + (x * 1)}
    elseif kbp(Enum.KeyCode.F) then
        translate_position = {translate_position[1] + (x * 1), translate_position[2], translate_position[3] - (y * 1)}
    elseif kbp(Enum.KeyCode.H) then
        translate_position = {translate_position[1] - (x * 1), translate_position[2], translate_position[3] + (y * 1)}
    elseif kbp(Enum.KeyCode.R) then
        translate_position = {translate_position[1], translate_position[2] + 1, translate_position[3]}
    elseif kbp(Enum.KeyCode.Y) then
        translate_position = {translate_position[1], translate_position[2] - 1, translate_position[3]}
    elseif kbp(Enum.KeyCode.Z) then
        camera_rotation = {camera_rotation[1] + 1, camera_rotation[2]}
    elseif kbp(Enum.KeyCode.X) then
        camera_rotation = {camera_rotation[1] - 1, camera_rotation[2]}
    elseif kbp(Enum.KeyCode.C) then
        camera_rotation = {camera_rotation[1], camera_rotation[2] + 1}
    elseif kbp(Enum.KeyCode.V) then
        camera_rotation = {camera_rotation[1], camera_rotation[2] - 1}
    end
    local s = math.round(size / 2)
    local wireframes = {
        getcube(0, 25 - s, 0, size, translate_position),
        getcube(size * 2, 25 - s, 0, size, translate_position),
        getcube(0, 25 - s, size * 2, size, translate_position),
        getcube(size * 2, 25 - s, size * 2, size, translate_position),
    }
    --[[
    local wireframes = {
        getcube(25 - s, 25 - s, 0, size, translate_position),
        getcube(25 - s, 25 - s, size, size, translate_position),
        getcube(25 - s, 25 - s, size * 2, size, translate_position),
        getcube(25 - s, 25 - s, size * 3, size, translate_position),
        getcube(25 - s, 25 - s, size * 4, size, translate_position),
        getcube(25 - s, 25 - s, size * 5, size, translate_position),
        getcube(25 - s, 25 - s, size * 6, size, translate_position),
        getcube(25 - s, 25 - s, size * 7, size, translate_position)
    }]]
    local rotated = rotatewireframes(wireframes, camera_rotation, camera_position)
    local rendered = renderthewireframes(rotated, focal_length, camera_position, camera_rotation[1])
    --print(rendered)
    coroutine.wrap(update)(rendered)
    task.wait(0.033)
end
